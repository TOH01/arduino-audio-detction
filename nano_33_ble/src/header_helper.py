import os
import numpy as np
import librosa

def generate_dsp_params_header(out_dir, sample_rate, n_fft, hop_length, expected_frames):
    with open(os.path.join(out_dir, "dsp_params.h"), 'w') as f:
        f.write('#ifndef DSP_PARAMS_H\n#define DSP_PARAMS_H\n\n')
        f.write('// Audio Preprocessing Constants\n')
        f.write(f'#define SAMPLE_RATE {sample_rate}\n')
        f.write(f'#define N_FFT {n_fft}\n')
        f.write(f'#define HOP_LENGTH {hop_length}\n')
        f.write(f'#define EXPECTED_FRAMES {int(expected_frames)}\n')
        f.write('\n#endif // DSP_PARAMS_H\n')


def generate_model_config_header(out_dir, model_name, motions, confidence, test_audio = None):
    with open(os.path.join(out_dir, "model_config.h"), 'w') as f:
        f.write('#ifndef MODEL_CONFIG_H\n#define MODEL_CONFIG_H\n\n')
        f.write(f'#include "{model_name}.h"\n\n')

        f.write(f'#define CONFIDENCE_THRESHOLD {confidence:.2f}\n')
        f.write(f'#define NUM_CLASSES {len(motions)}\n')
        f.write(f'#define MODEL_NAME "{model_name}"\n\n')

        if test_audio:
            f.write('#define INJECT_TEST_AUDIO\n\n')

        f.write('static const char* class_labels[NUM_CLASSES] = {\n')

        sorted_motions = sorted(motions, key=lambda x: x["label"])
        
        for motion in sorted_motions:
            f.write(f'  "{motion["name"]}",\n')
        f.write('};\n\n')
        
        f.write('#endif // MODEL_CONFIG_H\n')


def generate_model_header(out_dir, model_name, tflite_model):
    with open(os.path.join(out_dir, f"{model_name}.h"), 'w') as f:
        f.write("// Auto-generated by pipeline\n")
        f.write("#include <stdint.h>\n\n")
        f.write(f"const unsigned char {model_name}[] = {{\n")
        f.write(", ".join(f"0x{b:02x}" for b in tflite_model))
        f.write(f"\n}};\nconst unsigned int {model_name}_len = {len(tflite_model)};\n")


def generate_mel_filterbank_header(out_dir, sample_rate, n_fft, n_mfcc):
    n_mels = 40

    mel_basis = librosa.filters.mel(sr=sample_rate, n_fft=n_fft, n_mels=n_mels)

    dct_matrix = np.zeros((n_mfcc, n_mels), dtype=np.float32)
    for k in range(n_mfcc):
        for n in range(n_mels):
            dct_matrix[k, n] = np.cos(np.pi * k * (n + 0.5) / n_mels)

    dct_matrix[0, :] *= 1.0 / np.sqrt(n_mels)
    dct_matrix[1:, :] *= np.sqrt(2.0 / n_mels)

    n_bins = n_fft // 2 + 1

    with open(os.path.join(out_dir, "mel_filterbank.h"), 'w') as f:
        f.write("// Auto-generated Mel filterbank matching librosa\n")
        f.write("#ifndef MEL_FILTERBANK_H\n")
        f.write("#define MEL_FILTERBANK_H\n\n")

        f.write(f"#define N_MEL_FILTERS {n_mels}\n")
        f.write(f"#define N_FFT_BINS {n_bins}\n")
        f.write(f"#define N_MFCC_COEFFS {n_mfcc}\n\n")

        f.write("// Mel filterbank weights [n_mels][n_fft_bins]\n")
        f.write("static const float mel_filterbank[N_MEL_FILTERS][N_FFT_BINS] = {\n")

        for i, row in enumerate(mel_basis):
            f.write("  {")
            values = ", ".join(f"{v:.3f}f" for v in row)
            f.write(values)
            f.write("}" + ("," if i < n_mels - 1 else "") + "\n")

        f.write("};\n\n")

        f.write("// DCT-II matrix for MFCC [n_mfcc][n_mels]\n")
        f.write("static const float dct_matrix[N_MFCC_COEFFS][N_MEL_FILTERS] = {\n")

        for i, row in enumerate(dct_matrix):
            f.write("  {")
            values = ", ".join(f"{v:.6f}f" for v in row)
            f.write(values)
            f.write("}" + ("," if i < n_mfcc - 1 else "") + "\n")

        f.write("};\n\n")

        f.write("#endif // MEL_FILTERBANK_H\n")


def convert_wav_to_header(out_dir, wav_path, sample_rate):    
    audio, _ = librosa.load(wav_path, sr=sample_rate, mono=True)

    audio_int16 = (audio * 32768).clip(-32768, 32767).astype(np.int16)

    with open(os.path.join(out_dir, "audio_inject.h"), 'w') as f:
        f.write("#ifndef TEST_AUDIO_H\n")
        f.write("#define TEST_AUDIO_H\n\n")
        f.write(f"// Auto-generated from {os.path.basename(wav_path)}\n")
        f.write(f"const int test_audio_len = {len(audio_int16)};\n")
        f.write(f"const short test_audio_data[] = {{\n")
        
        for i, val in enumerate(audio_int16):
            f.write(f"{val}")
            if i < len(audio_int16) - 1:
                f.write(", ")
            if (i + 1) % 16 == 0:
                f.write("\n")
                
        f.write("\n};\n\n")
        f.write("#endif // TEST_AUDIO_H\n")
